---
title: "由一道题引申出的事件循环、let\var用法、iife、块级作用域"
date: 2019-04-10 23:00:46
tags:
  - JavaScript
---

> 没有错，这道题就是：
>
> ```js
> for (var i = 0; i< 10; i++){
> 	setTimeout(() => {
> 		console.log(i);
>     }, 1000)
> } // 10 10 10 10 ...
> ```

为什么这里会出现10次10，而不是我们预期的0-9呢？

### 运行时&&事件循环

首先我们得理解`setTimeout`中函数的执行时机，这里就要讲到一个运行时的概念。

#### 可视化描述

![js运行时](/assets/blogImg/runtime.svg)

#### 栈

函数调用形成了一个栈帧。

```js
function foo(b) {
  var a = 10;
  return a + b + 11;
}

function bar(x) {
  var y = 3;
  return foo(x * y);
}

console.log(bar(7)); // 返回 42
```

当调用 `bar` 时，创建了第一个帧 ，帧中包含了 `bar` 的参数和局部变量。当 `bar` 调用 `foo`时，第二个帧就被创建，并被压到第一个帧之上，帧中包含了 `foo` 的参数和局部变量。当 `foo`返回时，最上层的帧就被弹出栈（剩下 `bar` 函数的调用帧 ）。当 `bar` 返回的时候，栈就空了。

#### 堆

对象被分配在一个堆中，即用以表示一大块非结构化的内存区域。

#### 队列

一个 JavaScript 运行时包含了一个待处理的消息队列。每一个消息都关联着一个用以处理这个消息的函数。

在[事件循环](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/EventLoop#Event_loop)期间的某个时刻，运行时从最先进入队列的消息开始处理队列中的消息。为此，这个消息会被移出队列，并作为输入参数调用与之关联的函数。正如前面所提到的，调用一个函数总是会为其创造一个新的栈帧。

函数的处理会一直进行到执行栈再次为空为止；然后事件循环将会处理队列中的下一个消息（如果还有的话）。

#### 与这题的关联

这里`setTimeout`会等到当前队列执行完了之后再执行，即`for`循环结束后执行，而这个时候`i`的值已经是`10`了，所以会打印出来10个10这样的结果。

#### 引申出其他

js中